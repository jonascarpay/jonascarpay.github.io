<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:creator" content="@jonascarpay" />
  <meta name="dcterms.date" content="2021-01-28" />
  <title>The working programmer’s guide to setting up Haskell projects</title>
  <meta property="og:title" content="The working programmer’s guide to setting up Haskell projects" />
  <meta property="twitter:title" content="The working programmer’s guide to setting up Haskell projects" />
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="../style.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:creator" content="@jonascarpay" />
</head>
<body>
<div class="header">
	<a href="../index.html">&larr; Back</a>
</div>
<header id="title-block-header">
<h1 class="title">The working programmer’s guide to setting up Haskell projects</h1>
<p class="date">2021-01-28</p>
</header>
<p><strong>tl;dr:</strong> Nothing beats Haskell.nix for features and flexibility. To get started quickly, use the <a href="https://github.com/jonascarpay/template-haskell">template-haskell</a> project template.</p>
<hr />
<p>If you’ve ever tried to set up a Haskell project, you know that it can be extremely frustrating to get to a point where everything just werks<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. Of course, just compiling a project is not <em>that</em> hard, it’s when you have multiple projects, spanning multiple compiler versions, all requiring tooling compiled with the right GHC version, that things quickly turn into a mess. In this post I will outline what I think is currently the best way of setting up a Haskell project.</p>
<p>If you’re just starting out with Haskell, this guide is not for you. You’re probably best off just using <a href="https://www.fpcomplete.com/haskell/get-started/">Stack</a>. You will know when you’re ready.</p>
<h2 id="the-goal">The goal</h2>
<p>This is what I consider project nirvana:</p>
<h3 id="no-global-state">No global state</h3>
<p>GHC and tooling is far too sensitive to version issues and name clashes to have things globally installed. Every project should have its own dedicated shell which contains the right tools.</p>
<h3 id="modern-tooling">Modern tooling</h3>
<p>When we enter our shell, all parts of a modern Haskell setup should be available. By this I mean</p>
<ul>
<li><a href="https://github.com/haskell/haskell-language-server"><code>haskell-language-server</code></a></li>
<li><a href="https://github.com/tweag/ormolu"><code>ormolu</code></a></li>
<li><a href="https://github.com/ndmitchell/hoogle"><code>hoogle</code></a></li>
<li><a href="https://github.com/ndmitchell/hlint"><code>hlint</code></a><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></li>
<li><a href="https://github.com/ndmitchell/ghcid"><code>ghcid</code></a></li>
</ul>
<p>All of these tools need to be compiled with the same version of GHC as the rest of your project. We should be able to change the GHC version without breaking our tooling.</p>
<h3 id="minimal-configuration">Minimal configuration</h3>
<p>From deciding I want to make a project, to opening my editor and writing Haskell code cannot take more than 30 seconds.</p>
<h2 id="the-solution">The solution</h2>
<p>In my opinion, the key to get to this point is by using one of Haskell’s best kept secrets, <a href="https://github.com/input-output-hk/haskell.nix">IOHK’s <code>haskell.nix</code></a>. It is a collection of nix tools that are meant to replace the default Nix Haskell infrastructure. Even though it is not very well known or widely used, it is well-documented, actively maintained, and used in production.</p>
<p>The way that Haskell.nix works is that you define a Stack or Cabal project as normal, but you let Haskell.nix take care of acquiring dependencies and tools, and setting up a development shell.</p>
<p>Fair warning, while you don’t have to write a single line of nix code<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>, it helps a lot if you’re at least familiar with the basics of nix. I realize that is a non-starter for some people, and that’s OK, we can still be friends.</p>
<h3 id="why-not-just-use">Why not just use…</h3>
<h4 id="stackcabal">…Stack/Cabal</h4>
<p>As mentioned in the intro, getting all your tools to work properly can be very finicky, since the tools and your project all need to be compiled with the same version of GHC. This is true for individual projects, but it gets a lot worse if you have multiple projects requiring different versions of GHC. Haskell.nix makes this a non-issue.</p>
<h4 id="pure-nix">…“Pure” Nix</h4>
<p>As nice as Nix is, setting up a Haskell project and development environment in Nix can get very involved. Haskell.nix standardizes, streamlines, and automates the entire process, allowing you to focus on writing Haskell instead of Nix.</p>
<h2 id="setup">Setup</h2>
<h3 id="preliminary-setup">Preliminary setup</h3>
<p>First, you need the <a href="https://nixos.org/">nix package manager</a>.</p>
<p>Second, you need to set up the <a href="https://input-output-hk.github.io/haskell.nix/tutorials/getting-started/#setting-up-the-binary-cache">IOHK binary cache</a>. <em>Technically</em> this is optional, but if you don’t you will build GHC from scratch, which takes… a while.</p>
<h3 id="a-note-on-flakes">A note on flakes</h3>
<p>You may have heard of nix’s upcoming<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> new <em>flakes</em> feature. Flakes are a standardised and composable way of defining nix packages, and a natural fit for <code>haskell.nix</code>. Flakes are generally my preferred way of defining packages, but unfortunately, the feature is not yet very stable, which makes it hard for me to recommend to people new to nix.</p>
<p>If you feel adventurous at some point, take a look at <a href="https://input-output-hk.github.io/haskell.nix/tutorials/getting-started-flakes/">Getting started with flakes</a> section of the manual, or the <a href="https://github.com/jonascarpay/template-haskell/tree/flakes"><code>flakes</code> branch of <code>template-haskell</code></a>. The differences are:</p>
<ul>
<li><code>pkgs.nix</code> and <code>shell.nix</code> file have been replaced by the <code>flake.nix</code> file</li>
<li>you enter the shell using <code>nix shell</code> instead of <code>nix-shell</code></li>
<li>pinning <code>haskell.nix</code> is now done through <code>flake.lock</code></li>
<li>evaluation is a lot quicker</li>
<li>CI has been updated to work with flakes</li>
</ul>
<h3 id="project-setup">Project setup</h3>
<p>Unlike, say, Stack, Haskell.nix is <em>just</em> a Nix library, so it doesn’t have any CLI tools that create a project for you. For that reason, you’re going to want to use a project template that you copy whenever you start a new project. The Haskell.nix parts are going to be the exact same between your projects, so this should be very easy. You have two options here; you can use my <a href="https://github.com/jonascarpay/template-haskell">template-haskell</a> template project, or you can create your own.</p>
<h4 id="using-template-haskell">Using <a href="https://github.com/jonascarpay/template-haskell">template-haskell</a></h4>
<p>Run these commands, replacing <my-project> with whatever you want your project to be called.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> clone https://github.com/jonascarpay/template-haskell <span class="op">&lt;</span>my-project<span class="op">&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> <span class="op">&lt;</span>my-project<span class="op">&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ex">./wizard.sh</span></span></code></pre></div>
<p><code>wizard.sh</code> will prompt you for your info, replace all placeholders, and reinitialize the git history.</p>
<p>From here, enter the shell and you should have all tools available to you. If you want to change the GHC version, you can do so by changing the string in <code>pkgs.nix</code>.</p>
<h4 id="making-one-yourself">Making one yourself</h4>
<p>As mentioned before, Haskell.nix works <em>on top</em> of either a <code>stack.yaml</code> or <code>cabal.project</code>-based project definition. You don’t need <code>stack</code> or <code>cabal</code> <em>themselves</em>, but you will need a valid project. So, first order of business is to set that up. It doesn’t really matter how you do this, and you might already have a preferred way, but if not I recommend using Stack’s <code>stack new</code> command. Again, you only need to do this once.</p>
<p>Once done, you need to set up <code>Haskell.nix</code>. This is typically done by adding two Nix files; one that describes the project, and one that describes your development shell. The Haskell.nix manual has clear instructions for both parts, see <a href="https://input-output-hk.github.io/haskell.nix/tutorials/getting-started/#scaffolding">Scaffolding</a> and <a href="https://input-output-hk.github.io/haskell.nix/tutorials/development/#how-to-get-a-development-shell">How to get a development shell</a>. Getting the tools we want is a matter of adding them to the <code>tools</code> section in the <code>shellFor</code> section in <code>shell.nix</code>. As you can see you don’t actually have to specify their versions, you can put <code>"latest"</code>.</p>
<p>For reference, here are my <a href="https://github.com/jonascarpay/template-haskell/blob/master/pkgs.nix"><code>pkgs.nix</code></a> (what’s called <code>default.nix</code> in the manual) and <a href="https://github.com/jonascarpay/template-haskell/blob/master/shell.nix"><code>shell.nix</code></a>.</p>
<p>Once you’ve set up your project and shell, you can pretty much copy/share these two files between all your projects.</p>
<p>To turn your project into an actual template, you can make things as simple or fancy as you want. As mentioned above, in <code>template-haskell</code>, I just use a simple shell script that replaces a few placeholder strings, but if you want you could use something like <a href="https://github.com/cookiecutter/cookiecutter">cookiecutter</a>.</p>
<h2 id="adding-files-to-your-project">Adding files to your project</h2>
<p>Unlike the normal nix behavior, by default, <strong>Haskell.nix only sees files that are known to git.</strong> They can have changes, but a new file that has not at least been staged is completely invisible to Haskell.nix. If you run into issues building or entering the shell, always first make sure that all relevant files have at least been staged.</p>
<h2 id="building">Building</h2>
<p>You actually have two ways of building a project; purely with Nix or with Nix + Cabal. They have slightly different use cases, so it’s probably a good idea to familiarize yourself with both.</p>
<h3 id="building-with-nix-cabal">Building with Nix + Cabal</h3>
<p>This is probably closest to what you are already familiar with, and the one you typically use during development. You simply enter your project shell, and <code>cabal new-build</code> as normal:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> nix-shell</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ex">nix-shell$</span> cabal new-build</span></code></pre></div>
<p>Everything here is as normal, except for the fact that Cabal doesn’t have to worry about package databases, resolving and compiling dependencies, or GHC versions.</p>
<h3 id="building-with-nix">Building with Nix</h3>
<p>Haskell.nix also provides pure Nix derivations for your project. This means that instead of polluting your project directory with build artifacts, they end up in the Nix store, where they get garbage collected automatically.</p>
<p>Unfortunately, there are two things that make this pretty slow:</p>
<ul>
<li>Nix cannot do incremental builds within a single package</li>
<li>The Nix evaluation can add a few seconds of overhead.</li>
</ul>
<p>That means that you typically don’t want to use this during normal development, but it’s great for CI, or things that you don’t build often.</p>
<p>You build like this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> nix-build pkgs.nix <span class="at">-A</span> hsPkgs.<span class="op">&lt;</span>my-package<span class="op">&gt;</span>.components.<span class="op">&lt;</span>component<span class="op">&gt;</span></span></code></pre></div>
<p>Where <code>&lt;component&gt;</code> is one of:</p>
<ul>
<li><code>lib</code></li>
<li><code>exes.&lt;executable&gt;</code></li>
<li><code>tests.&lt;testsuite&gt;</code></li>
<li><code>benchmarks.&lt;bench&gt;</code></li>
</ul>
<p><strong>Tip:</strong> you can explore these from the Nix REPL like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> nix repl</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="ex">nix-repl</span><span class="op">&gt;</span> :l ./pkgs.nix</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="ex">nix-repl</span><span class="op">&gt;</span> hsPkgs.<span class="op">&lt;</span>my-package<span class="op">&gt;</span>.components.<span class="kw">|</span></span></code></pre></div>
<p>If you then press tab, the completion shows you the available components.</p>
<h2 id="troubleshooting">Troubleshooting</h2>
<h3 id="something-doesnt-work">Something doesn’t work</h3>
<p>If you’re like me, you probably just forgot to stage a file in git.</p>
<h3 id="nix-evaluation-is-slow">Nix evaluation is slow!</h3>
<p>See <a href="https://input-output-hk.github.io/haskell.nix/tutorials/materialization/#materialization">Materialization</a> or consider switching to flakes.</p>
<h3 id="the-shell-is-slow">The shell is slow!</h3>
<p>See the point about Materialization above, and/or consider using <a href="https://github.com/target/lorri"><code>lorri</code></a>, <a href="https://github.com/xzfc/cached-nix-shell"><code>cached-nix-shell</code></a>, or my personal favorite, <a href="https://github.com/nix-community/nix-direnv"><code>nix-direnv</code></a>. Nix flakes also helps out here.</p>
<h3 id="i-get-warnings-when-i-build-the-projectenter-my-nix-shell">I get warnings when I build the project/enter my <code>nix-shell</code>!</h3>
<p>This is also related to materialization, if you properly configure materialization the warnings will disappear. You can safely ignore these warnings, though, and I usually don’t bother.</p>
<h3 id="why-is-ci-building-ghc">Why is CI building GHC?</h3>
<p><code>template-haskell</code> also contains a CI matrix. The Nix pipeline uses cachix to cache builds, specifically the <code>jmc</code> cachix. You don’t have push access to this, so if you change something that triggers a GHC change it will be rebuilt every time. I recommend you create and set up your own personal cachix.</p>
<h3 id="i-cannot-rebuild-without-a-network-connection">I cannot rebuild without a network connection?</h3>
<p>This happens when nix tries to fetch one of the intermediate derivations from cache. Simply build with <code>--option substituters ""</code> to disable cache lookup.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Actually applies to every language<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p><code>hlint</code> and <code>ghcid</code> are somewhat obviated by HLS, but I like having them around for CI and running tests, respectively.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>If you want to start from scratch you might need to copy and paste some Nix from the Haskell.nix manual.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>it’s been upcoming for a long time.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
<div class="header">
	<a href="../index.html">&larr; Back</a>
</div>
<div class="footer">
	<a href="https://github.com/jonascarpay/jonascarpay.github.io">Questions/suggestions on Github</a> -
	<a href="https://jonascarpay.com/rss.xml">RSS</a> </br> </br>
	Made with pandoc and duct tape.
</div>
</body>
</html>
